\chapter{Аналитический раздел}

\section{Формализация объектов синтезируемой сцены}

Сцена состоит из следующих объектов:
\begin{enumerate}
	\item Ограничивающая плоскость --- расположена параллельно плоскости OXZ;
	\item Цветок --- расположен на ограничивающей плоскости. В нем можно выделить следующие составляющие:
	\begin{enumerate}[label*=\arabic*.]
		\item Стеблевая часть:
		\begin{enumerate}[label=\alph*)]
			\item Цветоножка --- длинный изогнутый цилиндр, описываемый следующими уравнениями:
			\begin{equation*}
				\begin{cases}
					x = 0.6\cos t + \frac{1}{5}\sin z,\\
					y = 0.6\sin t,\\
					z = z.
				\end{cases}
			\end{equation*}
			где $t \in [0;2\pi), z \in [0;20]$. 
			Здесь $z$ определяет высоту стебля. Выбор интервала основывался на размерах остальных частей цветка.
			
			\item Цветоложе --- часть эллипсоида, задаваемая уравнением:
			\begin{equation*}
				z = \frac{(x - \frac{1}{4})^2}{2} + \frac{y^2}{2}
			\end{equation*}
			при $x \in [-2.25; 2.75], y \in [-2.5;2.5]$.
			Интервалы для $x$ и $y$ были выбраны таким образом, чтобы часть эллипсоида имела характерные для цветоложа углубления.
			
			\item Лист --- поверхность, ограниченная парой кривых, описываемых следующими уравнениями:
			\begin{equation*}
				\begin{cases}
					x = t,\\
					y = \frac{1}{3}t^2,\\
					z = \frac{2}{t+1} + 3t.
				\end{cases}
			\end{equation*}
			где $t \in [0;5.2]$.
			
			Вторая кривая получается в результате поворота первой кривой на угол $\phi = \frac{-\pi}{3}$. Полученные уравнения, задающие вторую кривую:
			\begin{equation*}
				\begin{cases}
					x = t\cos\frac{-\pi}{3}-\frac{1}{3}t^2\sin\frac{-\pi}{3},\\
					y = t\sin\frac{-\pi}{3}+\frac{1}{3}t^2\cos\frac{-\pi}{3},\\
					z = \frac{-2}{t-1}-3t.
				\end{cases}
			\end{equation*}
			где $t \in [-5.2;0]$.
			
			Описанные выше кривые пересекаются в точках:
			$$ A(0;0;2), B(3\sqrt{3}; 9; \frac{2}{3\sqrt{3}} +9\sqrt{3}) $$
			
		\end{enumerate}
		\item Листовая часть --- совокупность поверхностей, образующих непосредственно лепестки цветка. Один лепесток описывается системой:
		\begin{equation*}
		\begin{cases}
			z = \frac{1}{2}x^2+y\\
			x^2+\frac{1}{5}y^2 \leq 3
		\end{cases}
		\end{equation*}
	\end{enumerate}
	\item Источник освещения --- начальное положение источника указывается по умолчанию, но пользователь может его изменить;
	\item Камера --- начальное положение источника указывается по умолчанию, но пользователь может его изменить.
\end{enumerate}

\section{Выбор способа определения моделей}

Модели могут задаваться в следующих формах \cite{models}:
\begin{itemize}[label=---]
	\item \textbf{Каркасная модель.} В данной модели задается информация о вершинах и ребрах объекта. Это одна из простейших форм задания модели. Основная проблема отображения объектов с помощью каркасной модели заключается в том, что модель не всегда однозначно передает представление о форме объекта.
	\item \textbf{Поверхностная модель.} Данный тип модели часто используется в компьютерной графике. Поверхность может описываться аналитически, либо задаваться другим способом. Недостатком поверхностной модели является отсутствие информации о том, с какой стороны поверхности находится материал.
	\item \textbf{Твердотельная модель.} Данная форма задания модели отличается от поверхностной формы тем, что в объемных моделях к информации о поверхностях добавляется информация о том, с какой стороны расположен материал. Это можно сделать путем указания направления внутренней нормали.
\end{itemize}

При рассмотрении объектов было сказано, что они представляют собой поверхности. Поэтому для решения поставленной задачи была выбрана поверхностная форма модели.

\section{Выбор алгоритма удаления невидимых ребер и поверхностей}

Алгоритмы удаления невидимых линий и поверхностей служат для определения поверхностей или объемов, которые видимы или невидимы для наблюдателя, находящегося в заданной точке пространства. Решать поставленную задачу удаления можно как в объектном пространстве (в мировой системе координат), так и в пространстве изображения (в экранных координатах).

Рассмотрим алгоритмы для удаления невидимых ребер и поверхностей.

\subsection{Алгоритм Робертса}

Алгоритм работает в объектном пространстве. Требуется, чтобы все изображаемые тела были выпуклыми. 

Алгоритм работает в 3 этапа: подготовка исходных данных, удаление ребер, экранируемых самим телом, удаление ребер, экранируемых другими телами.

\textbf{Этап 1. Подготовка исходных данных.}

Необходимо сформировать матрицы тел, которые будут представлять выпуклые твердые тела. В такой матрице каждый столбец содержит коэффициенты одной плоскости. При этом точки, лежащие внутри тела, дают положительное скалярное произведение с каждым столбцом матрицы.

\textbf{Этап 2. Удаление ребер, экранируемых самим телом.}

На данном этапе используется вектор направления взгляда: 
$$ E = [0; 0; -1; 0]$$
При умножении вектора E на матрицу тела отрицательные компоненты полученного вектора будут соответствовать задним граням. Если объект на сцене один, то работа алгоритма завершается на данном этапе.

\textbf{Этап 3. Удаление ребер, экранируемых другими телами.}

Необходимо провести луч из произвольной точки анализируемого отрезка в точку наблюдения. Если луч проходит через тело, то точка невидима, а луч расположен с положительной стороны от каждой грани тела.

\textbf{Преимущества \cite{rojers}:}
\begin{itemize}[label=---]
	\item Точность вычислений благодаря тому, что алгоритм работает в объектном пространстве;
	\item Использование математически простых и точных методов.
\end{itemize}

\textbf{Недостатки \cite{rojers}:}
\begin{itemize}[label=---]
	\item Возможность работать только с выпуклыми объектами;
	\item Сложность алгоритма $O(n^2)$, где $n$ --- количество объектов сцены.
\end{itemize}

\subsection{Алгоритм, использующий z-буфер}

Алгоритм работает в пространстве изображения. Основная идея: поиск по $x$ и $y$ наибольшего значения функции $z(x,y)$ \cite{lectures}.

Используются два буфера:
\begin{itemize}[label=---]
	\item Буфер кадра, используемый для запоминания интенсивности каждого пикселя;
	\item Z-буфер --- буфер глубины, используемый для запоминания координаты $z$ (глубины каждого видимого пикселя).
\end{itemize}

В начале работы алгоритма буфер кадра заполнен фоновым значением интенсивности или цвета, а z-буфер – минимальным значением координаты $z$. Также удаляются нелицевые грани, если это целесообразно. 

Затем каждый многоугольник преобразовывается в растровую форму в произвольном порядке. Для каждого пикселя в многоугольнике вычисляется его глубина и записывается в z-буфер, если она больше хранящегося значения.

\textbf{Преимущества:}
\begin{itemize}[label=---]
	\item Алгоритм делает тривиальной визуализацию пересечений сложных поверхностей;
	\item Сцены могут быть любой сложности;
	\item Сложность алгоритма $O(n)$, где $n$ --- количество объектов сцены;
	\item Экономия вычислительного времени, так как элементы сцены не сортируются.
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}[label=---]
	\item Большой объем требуемой памяти;
	\item Трудоемкость устранения лестничного эффекта.
\end{itemize}

\subsection{Алгоритм обратной трассировки лучей}

Алгоритм работает в пространстве изображения.

Наблюдатель видит объект благодаря испускаемому неким источником свету, который падает на этот объект и каким-либо образом доходит до наблюдателя: отразившись от поверхности, преломившись или пройдя через нее. Так как немногие из лучей, выпущенных источником, доходят до наблюдателя, то целесообразно трассировать (отслеживать) лучи в обратном направлении – от наблюдателя к объекту \cite{lectures}.

Предполагается, что сцена уже преобразована в пространство изображения. Каждый луч, исходящий от наблюдателя, проходит через центр пикселя на растре до сцены. Траектория каждого луча отслеживается, чтобы определить, какие именно объекты сцены, пересекаются с данным лучом. Необходимо проверить пересечение каждого объекта сцены с каждым лучом. Если луч пересекает объект, то определяются все возможные точки пересечения луча и объекта. Можно получить большое количество пересечений, если рассматривать много объектов. Эти пересечения упорядочиваются по глубине. Пересечение с максимальным значением координаты z представляет видимую поверхность для данного пикселя. Атрибуты этого объекта используются для определения характеристик пикселя. 

Если точка зрения находится не в бесконечности, предполагается, что наблюдатель по-прежнему находится на положительной полуоси $z$. Картинная плоскость, перпендикулярна оси $z$. Задача состоит в построении одноточечной центральной проекции на картинную плоскость. 

\textbf{Преимущества:}
\begin{itemize}[label=---]
	\item Высокая реалистичность получаемого изображения;
	\item Простота модификации при работе с несколькими источниками освещения, реализации различных оптических явлений;
	\item Алгоритм не требует дополнительных вычислений для нахождения теней.
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}[label=---]
	\item Большая трудоемкость вычислений.
\end{itemize}

\subsection{Алгоритм Варнока}

Алгоритм работает в пространстве изображения.

В пространстве изображения рассматривается окно и решается вопрос о том, пусто ли оно, или его содержимое достаточно просто для визуализации. Если это не так, то окно разбивается на фрагменты до тех пор, пока содержимое подокна не станет достаточно простым для визуализации или его размер не достигнет требуемого предела разрешения. В последнем случае информация, содержащаяся в окне, усредняется, и результат изображается с одинаковой интенсивностью или цветом \cite{lectures}. 

Устранение лестничного эффекта можно реализовать, доведя процесс разбиения до размеров, меньших, чем разрешение экрана на один пиксель, и усредняя атрибуты подпикселей, чтобы определить атрибуты самих пикселей.

\textbf{Преимущества:}
\begin{itemize}[label=---]
	\item Эффективность для простых сцен;
	\item Простота устранения лестничного эффекта.
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}[label=---]
	\item Неэффективность при большом количестве объектов.
\end{itemize}

\subsection*{Вывод}

Сравнение описанных выше алгоритмов представлено таблицей~\ref{tbl:alg}.

\begin{table}[H]
	\begin{center}
		\captionsetup{justification=raggedright, singlelinecheck=off}
		\caption{Результаты замеров времени для произвольных массивов}
		\label{tbl:alg}
			\begin{tabularx}{\textwidth}{|p{3.5cm}|p{2.5cm}|p{3cm}|p{3cm}|p{2.81cm}|}
				\hline
				& Алгоритм Робертса & Алгоритм, использующий z-буфер&Алгоритм обратной трассировки лучей &Алгоритм Варнока\\
				\hline
				Сложность алгоритма ($N$ --- количество граней, $C$ --- количество пикселей) & $O(N^2)$ &$O(CN)$ &$O(CN)$&$O(CN)$\\
				\hline
				Эффективность для сцен с большим количеством объектов &Низкая & Высокая&Низкая &Средняя\\
				\hline
				Пространство работы алгоритма &Объектное пространство &Пространство изображений & Пространство изображений& Пространство изображений\\
				\hline
				Сложность реализации &Высокая &Низкая & Средняя& Средняя\\
				\hline
			\end{tabularx}
	\end{center}
\end{table}

Таким образом, для решения данной задачи был выбран алгоритм, использующий z-буфер, так как он отвечает заявленным требованиям при постановке задачи.

\section{Выбор алгоритма построения теней}

Поскольку в качестве алгоритма удаления невидимых линий и поверхностей был выбран алгоритм, использующий z-буфер, для построения теней будет использована его модификация \cite{cg}. 

Строится сцена из точки наблюдения, совпадающей с источником. Значения $z$ для этого вида хранятся в отдельном теневом z-буфере. Значения интенсивности не рассматриваются.

Затем сцена строится из точки, в которой находится наблюдатель. При обработке каждой поверхности или многоугольника его глубина в каждом пикселе сравнивается с глубиной в z-буфере наблюдателя. Если поверхность видима, то значения $(x, y, z)$ из вида наблюдателя линейно преобразуются в значения $(x', y', z')$ на виде из источника. Для того чтобы проверить, видимо ли значение $z'$ из положения источника, оно сравнивается со значением теневого z-буфера при $x', y'$. Если оно видимо, то оно отображается в буфер кадра в точке $x$, $y$ без изменений. Если нет, то точка находится в тени и изображается согласно соответствующему правилу расчета интенсивности с учетом затенения, а значение в z-буфере наблюдателя заменяется на $z'$ \cite{zbufmoduf}\cite{shadows}.


\section{Анализ методов закрашивания}

Существует несколько методов закрашивания. Рассмотрим некоторые из них.

\subsection{Простая закраска}

Вся грань закрашивается одним уровнем интенсивности. Используется минимальное количество вычислений, но снижается качество получаемого изображения \cite{fill}.

Используется при выполнении трех условий:
\begin{enumerate}
	\item Предполагается, что источник находится в бесконечности;
	\item Предполагается, что наблюдатель находится в бесконечности;
	\item Закрашиваемая грань является реально существующей, а не полученной в результате аппроксимации поверхности.
\end{enumerate}

Недостатком является возникновение ребер. При закраске каждой грани со своей интенсивностью граница между ними становится видна, и возникают ребра \cite{simplefill}.

\subsection{Закраска по Гуро}

Закраска по Гуро выполняет сглаживание на основе биполярной интерполяции интенсивности \cite{algFill}.

Вводится понятие нормали к вершине, на основе которой вычисляется интенсивность каждой вершины и выполняется первая интерполяция вдоль ребер. Вторая интерполяция выполняется при вычислении интенсивности пикселей, расположенных на сканирующей строке. Качество изображения улучшится. Граница между двумя гранями визуально сгладится.

Закраска по Гуро не предусматривает учет кривизны поверхности. При применении закраски по Гуро возможно получение плоского изображения, когда углы, образованные гранями, одинаковые.

Закраска по Гуро хорошо сочетается с диффузной составляющей поверхности (матовой).

\subsection{Закраска по Фонгу}

Основная идея закраски по Фонгу: интерполировать нормали, а не интенсивности, как в закраске по Гуро.

От точки к точке в пределах грани нормали изменяются, учитывается криволинейный характер поверхности. Изображение получается более качественное, но трудоёмкость закраски по Фонгу будет выше.

Закраска по Фонгу хорошо сочетается с зеркальной составляющей: моделирует блики, возникающие при зеркальном отражении \cite{intuit}.

\subsection*{Вывод}

Результаты сравнения алгоритмов закраски представлены таблицей \ref{tbl:fill}

\begin{table}[H]
	\begin{center}
		\captionsetup{justification=raggedright, singlelinecheck=off}
		\caption{Сравнение алгоритмов закраски}
		\label{tbl:fill}
		\begin{tabularx}{\textwidth}{|p{3.5cm}|p{3.8cm}|p{3.8cm}|p{4.145cm}|}
			\hline
			&Простая закраска &Закраска по Гуро&Закраска по Фонгу\\ \hline
			Реалистичность получаемого изображения&Низкая&Средняя&Высокая\\ \hline
			Эффективность для сцен с большим количеством объектов&Высокая&Средняя&Низкая\\ \hline
			Сочетаемость с диффузной составляющей поверхности&Нет&Да&Нет\\ \hline
		\end{tabularx}
	\end{center}
\end{table}

Для данной задачи был выбран алгоритм закраски по Гуро, так как он отвечает заявленным требованиям при постановке задачи.

\section*{Вывод}

В данном разделе были формализованы объекты синтезируемой сцены, проведен обзор предметной области: рассмотрены существующие методы удаления невидимых линий и поверхностей, методы закрашивания и методы удаления теней. Из рассмотренных методов были выбраны алгоритмы для решения поставленной задачи.

В качестве алгоритма удаления невидимых линий и поверхностей был
выбран алгоритм, использующий Z-буфер. В качестве алгоритма закрашивания
была выбрана закраска по Гуро. В качестве алгоритма построения теней была выбрана модификация алгоритма, использующего Z-буфер.
